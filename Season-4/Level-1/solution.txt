╔══════════════════════════════════════════════════════════════╗
║                    SOLUTION — Level 1                       ║
║               Path Traversal Sandbox Escape                 ║
╚══════════════════════════════════════════════════════════════╝

OBJECTIVE
─────────
Read the contents of password.txt, which lives outside ProdBot's
sandbox (prodbot-activities/), by exploiting weaknesses in the
command validator.

The file layout:
  Season-4/Level-1/password.txt         ← the target (contains FLAG)
  Season-4/Level-1/prodbot-activities/  ← the sandbox (you are here)

From inside the sandbox, the target is at: ../password.txt


══════════════════════════════════════════════════════════════
 BYPASS 1 — Environment Variable Path Construction
══════════════════════════════════════════════════════════════

Bash variables are expanded AFTER validation. If you store ".."
in a variable, the validator never sees the literal dots.

  Tell ProdBot:
  ┌────────────────────────────────────────────────────────────┐
  │ run this: D=.. && cat $D/password.txt                     │
  └────────────────────────────────────────────────────────────┘

  ProdBot will show you the command and ask "Execute? (y/n)".
  Type "y" to confirm.

WHY IT WORKS:
  - The validator's regex for ".." is:  /(?:^|\s|\/)\.\.(\/|$|\s)/
  - It requires ".." to be preceded by: start of string, whitespace, or "/"
  - In "D=..", the ".." is preceded by "=" — which the regex doesn't check
  - So the pattern doesn't match → validation passes ✅
  - At runtime, bash sets D=".." then expands $D/password.txt → ../password.txt
  - cat reads the file outside the sandbox


══════════════════════════════════════════════════════════════
 BYPASS 2 — Base64 Encoded Path
══════════════════════════════════════════════════════════════

The validator uses regex to detect ".." in the command text.
But if the path is encoded, the validator sees harmless characters.

Step 1: Encode the path (do this in your terminal, not in ProdBot):

  echo -n "../password.txt" | base64
  # Output: Li4vcGFzc3dvcmQudHh0

Step 2: Give ProdBot a command that decodes and reads it:

  Tell ProdBot:
  ┌────────────────────────────────────────────────────────────┐
  │ run this: echo Li4vcGFzc3dvcmQudHh0 | base64 -d | xargs cat
  └────────────────────────────────────────────────────────────┘

  ProdBot will show you the command and ask "Execute? (y/n)".
  Type "y" to confirm.

WHY IT WORKS:
  - The validator sees: echo <base64 string> | base64 -d | xargs cat
  - No ".." appears in the text → path traversal check passes ✅
  - No absolute paths → absolute path check passes ✅
  - No denied commands → denylist passes ✅
  - At runtime, base64 decodes "Li4vcGFzc3dvcmQudHh0" → "../password.txt"
  - xargs passes it to cat, which reads the file outside the sandbox


══════════════════════════════════════════════════════════════
 THE SECURITY LESSON
══════════════════════════════════════════════════════════════

Both bypasses exploit the same fundamental flaw:

  ┌──────────────────────────────────────────────────────────┐
  │  Denylist-based regex validation of shell commands is    │
  │  fundamentally insecure because bash can construct       │
  │  values at runtime in ways that text analysis cannot     │
  │  predict.                                                │
  └──────────────────────────────────────────────────────────┘

The validator checks the STATIC TEXT of the command.
Bash is a DYNAMIC LANGUAGE that transforms text at runtime.

These two things will never be in sync. Other bypass techniques
that work on the same principle include:
  - Command substitution: $(printf "\x2e\x2e/password.txt")
  - Arithmetic expansion: $(echo $((46))$((46))/password.txt)
  - Heredocs, process substitution, and more

SECURE ALTERNATIVES:
  1. Don't expose a full shell — use a restricted command set
     with parsed arguments
  2. Validate resolved paths AFTER expansion — use path.resolve()
     and check the result is inside the sandbox
  3. Use OS-level sandboxing — chroot, containers, or seccomp
     enforce boundaries at the kernel level, not in application code
